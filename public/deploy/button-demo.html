<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swipe Button Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #111;
      font-family: system-ui, -apple-system, "Segoe UI", Tahoma, Arial, sans-serif;
      padding: 20px;
    }

    .demo-container {
      text-align: center;
    }

    .demo-title {
      color: #fff;
      font-size: 24px;
      margin-bottom: 40px;
      font-weight: 700;
    }

    /* Main Button Styles - Toggle Switch Design */
    .swipe-button {
      position: relative;
      display: inline-flex;
      align-items: center;
      padding: 8px 16px 8px 44px; /* Increased left padding to clear the green ball */
      background: rgba(42, 42, 42, 0.4); /* 60% transparent */
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 50px;
      color: #e0e0e0;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      margin-left: 35px; /* Space for the larger green circle */
      animation: blink 1.2s ease-in-out infinite; /* Flashing effect */
    }

    /* Arrow Circle Container - Positioned ON TOP of left edge */
    .arrow-circle {
      position: absolute;
      left: -30px; /* Half outside the container */
      top: 50%;
      transform: translateY(-50%);
      width: 64px;
      height: 64px;
      background: rgba(0, 255, 136, 0.3); /* 70% transparent green */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
      z-index: 10; /* Ensure it's on top */
      cursor: grab;
      transition: left 0.3s ease, box-shadow 0.3s ease;
    }

    .arrow-circle.dragging {
      cursor: grabbing;
      transition: none;
      box-shadow: 0 0 35px rgba(0, 255, 136, 0.8);
    }

    .swipe-button.dragging {
      animation: none;
    }

    .swipe-button.dragging .arrow-icon {
      animation: none;
    }

    /* Arrow Icon (Pure CSS) */
    .arrow-icon {
      position: relative;
      width: 24px;
      height: 24px;
      animation: slideRight 2s ease-in-out infinite;
    }

    .arrow-icon::before,
    .arrow-icon::after {
      content: '';
      position: absolute;
      background: #ffffff; /* White arrow for better contrast with transparent green */
      border-radius: 2px;
    }

    /* Arrow shaft */
    .arrow-icon::before {
      width: 18px;
      height: 3px;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Arrow head - connected to shaft with no gap */
    .arrow-icon::after {
      width: 9px;
      height: 9px;
      right: -1px;
      top: 50%;
      transform: translateY(-50%) rotate(45deg);
      border-right: 3px solid #ffffff; /* White arrow head */
      border-top: 3px solid #ffffff;
      background: transparent;
    }

    /* Looping Animation - Arrow slides right and returns */
    @keyframes slideRight {
      0%, 100% {
        transform: translateX(0);
      }
      50% {
        transform: translateX(8px);
      }
    }

    /* Blink/Flash Animation (like Menu button) */
    @keyframes blink {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.35;
      }
    }

    /* Hover/Touch Effect */
    .swipe-button:hover {
      background: rgba(58, 58, 58, 0.4); /* 60% transparent on hover */
      border-color: rgba(0, 255, 136, 0.3);
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.4),
        0 0 40px rgba(0, 255, 136, 0.2);
      transform: translateY(-2px);
    }

    .swipe-button:hover .arrow-circle {
      background: rgba(0, 255, 102, 0.35); /* Slightly more opaque on hover */
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
    }

    /* Active/Touch state */
    .swipe-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    /* Button Text */
    .button-text {
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .button-text::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 0%;
      background: rgba(42, 42, 42, 0.95);
      transition: width 0.1s linear;
    }

    .swipe-button.swiping .button-text::after {
      transition: none;
    }

    /* Variations showcase */
    .variations {
      margin-top: 60px;
      display: flex;
      flex-direction: column;
      gap: 30px;
      align-items: center;
    }

    .variation-label {
      color: #888;
      font-size: 14px;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Alternative color schemes */
    .swipe-button.alt-blue .arrow-circle {
      background: #00d4ff;
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
    }

    .swipe-button.alt-blue:hover {
      border-color: rgba(0, 212, 255, 0.3);
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.4),
        0 0 40px rgba(0, 212, 255, 0.2);
    }

    .swipe-button.alt-yellow .arrow-circle {
      background: #ffeb3b;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.4);
    }

    .swipe-button.alt-yellow:hover {
      border-color: rgba(255, 235, 59, 0.3);
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.4),
        0 0 40px rgba(255, 235, 59, 0.2);
    }

    /* Reverse direction swipe button (ball on right, swipes left) */
    .swipe-button.reverse {
      padding: 8px 44px 8px 16px; /* Right padding for ball */
      margin-left: 0;
      margin-right: 35px; /* Space for the ball on right */
    }

    .swipe-button.reverse .arrow-circle {
      left: auto;
      right: -30px; /* Position on right side */
    }

    /* Reverse arrow - pointing left <-- */
    .swipe-button.reverse .arrow-icon::before {
      /* Shaft extends from left to right */
      width: 18px;
      height: 3px;
      left: 0;
      top: 50%;
      right: auto;
      transform: translateY(-50%);
    }

    .swipe-button.reverse .arrow-icon::after {
      /* Arrow head on left side pointing left < */
      width: 9px;
      height: 9px;
      left: -1px;
      top: 50%;
      right: auto;
      transform: translateY(-50%) rotate(45deg);
      border-left: 3px solid #ffffff;
      border-bottom: 3px solid #ffffff;
      border-right: none;
      border-top: none;
      background: transparent;
    }

    .swipe-button.reverse .arrow-icon {
      animation: slideLeft 2s ease-in-out infinite;
    }

    @keyframes slideLeft {
      0%, 100% {
        transform: translateX(0);
      }
      50% {
        transform: translateX(-8px);
      }
    }

    /* Responsive */
    @media (max-width: 600px) {
      .swipe-button {
        font-size: 14px;
        padding: 6px 14px 6px 38px; /* Increased left padding for mobile */
        margin-left: 28px;
      }

      .swipe-button.reverse {
        padding: 6px 38px 6px 14px;
        margin-left: 0;
        margin-right: 28px;
      }

      .arrow-circle {
        width: 54px;
        height: 54px;
        left: -24px;
      }

      .swipe-button.reverse .arrow-circle {
        left: auto;
        right: -24px;
      }

      .arrow-icon {
        width: 20px;
        height: 20px;
      }

      .demo-title {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="demo-container">
    <h1 class="demo-title">Interactive Swipe Button Demo</h1>

    <!-- Primary Design -->
    <div>
      <p class="variation-label">Primary Design (Green) - Drag the ball →</p>
      <a href="#" class="swipe-button" onclick="alert('Button clicked!'); return false;">
        <div class="arrow-circle">
          <div class="arrow-icon"></div>
        </div>
        <span class="button-text">Swipe to Explore</span>
      </a>
    </div>

    <!-- Reverse Direction Design -->
    <div style="margin-top: 30px;">
      <p class="variation-label">Reverse Design (Green) - Drag the ball ←</p>
      <a href="#" class="swipe-button reverse" onclick="alert('Menu clicked!'); return false;">
        <span class="button-text">Swipe to Menu</span>
        <div class="arrow-circle">
          <div class="arrow-icon"></div>
        </div>
      </a>
    </div>

    <!-- Color Variations -->
    <div class="variations">
      <div>
        <p class="variation-label">Alternative - Blue (Try swiping!)</p>
        <a href="#" class="swipe-button alt-blue" onclick="alert('Blue variant clicked!'); return false;">
          <div class="arrow-circle">
            <div class="arrow-icon"></div>
          </div>
          <span class="button-text">Swipe to Explore</span>
        </a>
      </div>

      <div>
        <p class="variation-label">Alternative - Yellow (Try swiping!)</p>
        <a href="#" class="swipe-button alt-yellow" onclick="alert('Yellow variant clicked!'); return false;">
          <div class="arrow-circle">
            <div class="arrow-icon"></div>
          </div>
          <span class="button-text">Swipe to Explore</span>
        </a>
      </div>
    </div>

    <div style="margin-top: 60px; color: #666; font-size: 14px;">
      <p>✓ Bi-directional swipe functionality (left-to-right & right-to-left)</p>
      <p>✓ Text fades as ball moves over it</p>
      <p>✓ Touch and mouse drag support</p>
      <p>✓ Auto-reset if not swiped fully</p>
      <p>✓ Responsive design</p>
    </div>
  </div>

  <script>
    // Swipe to unlock functionality
    document.querySelectorAll('.swipe-button').forEach(button => {
      const circle = button.querySelector('.arrow-circle');
      const text = button.querySelector('.button-text');
      const isReverse = button.classList.contains('reverse');

      let isDragging = false;
      let startX = 0;
      let currentX = 0;
      let initialLeft = isReverse ? null : -30; // Will be calculated for reverse
      let initialRight = isReverse ? -30 : null; // For reverse buttons

      // Get the maximum distance the circle can travel
      function getMaxDistance() {
        const buttonWidth = button.offsetWidth;
        const circleWidth = circle.offsetWidth;
        return buttonWidth - circleWidth / 2 - 16; // 16px padding
      }

      function getMinDistance() {
        return isReverse ? -getMaxDistance() : initialLeft;
      }

      function updateTextVisibility(progress) {
        // Hide text as ball moves over it (progress 0-1)
        text.style.setProperty('--mask-width', `${progress * 100}%`);
        if (text.querySelector('::after')) {
          text.style.setProperty('width', `${(1 - progress) * 100}%`);
        }
        // Use pseudo-element to cover text
        const overlay = text.nextElementSibling;
        if (!overlay || !overlay.classList.contains('text-overlay')) {
          const newOverlay = document.createElement('div');
          newOverlay.className = 'text-overlay';
          newOverlay.style.cssText = `
            position: absolute;
            left: ${button.querySelector('.button-text').offsetLeft}px;
            top: 50%;
            transform: translateY(-50%);
            height: 100%;
            width: 0%;
            background: transparent;
            pointer-events: none;
            z-index: 5;
          `;
          button.appendChild(newOverlay);
        }

        // Update text opacity based on ball position
        const textBounds = text.getBoundingClientRect();
        const circleBounds = circle.getBoundingClientRect();
        const overlap = Math.max(0, Math.min(circleBounds.right, textBounds.right) - Math.max(circleBounds.left, textBounds.left));
        const textWidth = textBounds.width;
        const hideProgress = Math.min(1, overlap / textWidth);

        text.style.opacity = 1 - hideProgress;
      }

      function startDrag(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;

        if (isReverse) {
          currentX = parseInt(circle.style.right || initialRight);
        } else {
          currentX = parseInt(circle.style.left || initialLeft);
        }

        circle.classList.add('dragging');
        button.classList.add('dragging', 'swiping');

        e.preventDefault();
      }

      function onDrag(e) {
        if (!isDragging) return;

        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const deltaX = clientX - startX;

        if (isReverse) {
          // For reverse: ball starts on right, moves left (needs to move right property)
          const newRight = Math.max(initialRight, Math.min(currentX - deltaX, getMaxDistance()));
          circle.style.right = `${newRight}px`;
          circle.style.left = 'auto';

          // Calculate progress (0 to 1) - swipe from right to left
          const maxDist = getMaxDistance() - initialRight;
          const progress = Math.max(0, Math.min(1, (newRight - initialRight) / maxDist));
          updateTextVisibility(progress);
        } else {
          // Normal: ball starts on left, moves right
          const newLeft = Math.max(initialLeft, Math.min(currentX + deltaX, getMaxDistance()));
          circle.style.left = `${newLeft}px`;

          // Calculate progress (0 to 1)
          const maxDist = getMaxDistance() - initialLeft;
          const progress = Math.max(0, Math.min(1, (newLeft - initialLeft) / maxDist));
          updateTextVisibility(progress);
        }

        e.preventDefault();
      }

      function endDrag(e) {
        if (!isDragging) return;

        isDragging = false;
        circle.classList.remove('dragging');
        button.classList.remove('dragging');

        let progress;
        const maxDist = getMaxDistance();

        if (isReverse) {
          const currentRight = parseInt(circle.style.right || initialRight);
          progress = (currentRight - initialRight) / (maxDist - initialRight);

          // Check if swiped far enough (80% threshold)
          if (progress >= 0.8) {
            // Success! Trigger action
            circle.style.right = `${maxDist}px`;
            text.style.opacity = '0';

            setTimeout(() => {
              alert('Menu swipe completed!');
              resetSwipe();
            }, 300);
          } else {
            // Reset to initial position
            resetSwipe();
          }
        } else {
          const currentLeft = parseInt(circle.style.left || initialLeft);
          progress = (currentLeft - initialLeft) / (maxDist - initialLeft);

          // Check if swiped far enough (80% threshold)
          if (progress >= 0.8) {
            // Success! Trigger action
            circle.style.left = `${maxDist}px`;
            text.style.opacity = '0';

            setTimeout(() => {
              alert('Swipe completed! Navigating...');
              resetSwipe();
            }, 300);
          } else {
            // Reset to initial position
            resetSwipe();
          }
        }
      }

      function resetSwipe() {
        button.classList.remove('swiping');

        if (isReverse) {
          circle.style.right = `${initialRight}px`;
          circle.style.left = 'auto';
        } else {
          circle.style.left = `${initialLeft}px`;
        }

        text.style.opacity = '1';

        // Clean up any overlay
        const overlay = button.querySelector('.text-overlay');
        if (overlay) overlay.remove();
      }

      // Mouse events
      circle.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', endDrag);

      // Touch events
      circle.addEventListener('touchstart', startDrag, { passive: false });
      document.addEventListener('touchmove', onDrag, { passive: false });
      document.addEventListener('touchend', endDrag);

      // Prevent default click when dragging
      button.addEventListener('click', (e) => {
        if (button.classList.contains('swiping')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
    });
  </script>
</body>
</html>
