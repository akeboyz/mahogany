<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Signage Player</title>
  <!-- Cache busting: v2.0 -->
  <meta name="color-scheme" content="dark light"/>
  <link rel="icon" href="data:,">

  <!-- Inline Configuration for Yodeck Compatibility -->
  <script>
    // Digital Signage Configuration
    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô PROJECT_ID ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ project ‡∏≠‡∏∑‡πà‡∏ô
    window.CONFIG = {
      PROJECT_ID: 'prj001',  // <- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ: prj001, prj002, prj003, etc.
      DEFAULT_PAGE: 'index.html',
      VERSION: '1.0.1'
    };
  </script>

  <style>
    :root{ --cta-bg: rgba(200,200,200,.35); --cta-border: rgba(255,255,255,.45); --cta-text: #fff; }

    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#000}
    body{color:#333;overflow:hidden;font-family:system-ui,-apple-system,"Segoe UI",Tahoma,Arial,sans-serif}

    /* ‚úÖ ‡∏Å‡∏£‡∏≠‡∏ö‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠ + ‡∏™‡πÄ‡∏Å‡∏•‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏ü‡∏£‡∏° (‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö announce.html) */
    .safe-viewport{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden}
    #frame{position:absolute;left:50%;top:50%;width:1080px;height:1920px;background:#000;overflow:hidden;
           transform:translate(-50%,-50%) scale(1);transform-origin:center center;will-change:transform}

    /* ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏∑‡πà‡∏≠ */
    .stage{position:absolute;inset:0;background:#000}
    video,img,iframe{position:absolute;inset:0;width:100%;height:100%;background:#000}
    video,img{object-fit:contain} /* ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å cover ‡πÑ‡∏î‡πâ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏£‡∏≠‡∏ö */
    iframe{border:0}

    /* ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ */
    #status{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      color:#ddd;font-weight:700;text-align:center;z-index:90;padding:10px 14px;border-radius:10px;
      background:rgba(0,0,0,.35);display:none}
    #status.show{display:block}

    /* ‚úÖ CTA overlays (matching announce.html) */
    .cta-head, .cta-main {
      position: absolute;
      z-index: 80;
      font-size: 60px;
      font-weight: 700;
      letter-spacing: .5px;
      text-shadow: 0 2px 6px rgba(0,0,0,.45);
      color: #fff;
      user-select: none;
      pointer-events: none;
    }
    .cta-head { top: 24px; left: 24px; }
    .cta-main { top: 24px; right: 24px; pointer-events: auto; cursor: pointer; }
    .blink { animation: blink 1.2s ease-in-out infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.35} }

    #headCta{position:absolute;left:24px;top:24px;z-index:80;display:flex}
    #floatCta{
      margin:0;padding:8px 14px;border:0;border-radius:999px;background:transparent;box-shadow:none;color:#fff;
      font-weight:700;font-size:40px;letter-spacing:.5px;text-shadow:0 2px 6px rgba(0,0,0,.45);
      display:none;align-items:center;gap:8px;max-inline-size:min(72%,520px);
      white-space:normal;overflow-wrap:anywhere;hyphens:auto;text-wrap:balance;
      user-select:none;pointer-events:auto;cursor:pointer;-webkit-tap-highlight-color:transparent;
    }
    #floatCta:hover{opacity:.9} #floatCta:active{opacity:.75}

    .blink{animation:blink 1.2s ease-in-out infinite}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:.35}}

    /* ‡∏õ‡∏∏‡πà‡∏°‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á */
    #unlock{
      position:absolute;right:16px;top:16px;z-index:100;
      padding:10px 14px;border-radius:10px;border:0;cursor:pointer;
      font:600 15px system-ui;background:#1a73e8;color:#fff;
      box-shadow:0 6px 18px rgba(0,0,0,.32);display:none;
    }

    #ver{position:absolute;left:12px;bottom:12px;z-index:100;font-size:12px;color:#9aa5b1;opacity:.7;user-select:none}

    /* Smooth fade transitions for announcements */
    #img, #ann, #web {
      transition: opacity 0.75s ease-in-out;
    }

    .fade-out {
      opacity: 0 !important;
    }

    .fade-in {
      opacity: 1 !important;
    }
  </style>
</head>
<body>

  <div class="safe-viewport">
    <!-- ‚úÖ ‡πÄ‡∏ü‡∏£‡∏°‡∏Ñ‡∏á‡∏ó‡∏µ‡πà 1080√ó1920 -->
    <div id="frame">
      <div class="stage" aria-live="polite">
        <!-- A) ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠/‡∏£‡∏π‡∏õ -->
        <video id="v" playsinline preload="metadata" muted></video>
        <img id="img" alt=""/>

        <!-- B) ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏® (iframe) -->
        <iframe id="ann" allow="autoplay; fullscreen" style="display:none"></iframe>

        <!-- C) URL ‡∏≠‡∏∑‡πà‡∏ô ‡πÜ -->
        <iframe id="web" allow="autoplay; fullscreen" style="display:none"></iframe>
      </div>

      <!-- Working overlays for video player -->
      <div id="ctaHead" class="cta-head blink">Tap to explore</div>
      <div id="ctaMain" class="cta-main blink">‚ò∞ Menu</div>

      <!-- overlay ‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡πÄ‡∏ü‡∏£‡∏° -->
      <div id="status"></div>
      <div id="ver"></div>
      <!-- Audio button removed -->
    </div>
  </div>

  <!-- BGM element kept for compatibility but muted -->
  <audio id="bgm" preload="auto" playsinline muted></audio>

  <script>
    /* =============== fit ‡πÄ‡∏ü‡∏£‡∏°‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏à‡∏≠ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô announce.html) =============== */
    (function fit(){
      const DESIGN_W=1080, DESIGN_H=1920, frame=document.getElementById('frame');
      function apply(){
        const s=Math.min(window.innerWidth/DESIGN_W, window.innerHeight/DESIGN_H);
        frame.style.transform=`translate(-50%,-50%) scale(${s})`;
      }
      addEventListener('resize',apply); addEventListener('orientationchange',apply);
      addEventListener('pageshow',apply); addEventListener('DOMContentLoaded',apply);
    })();

    /* ===================== BGM ===================== */
    (function bgmLoop(){
      const audio  = document.getElementById('bgm');
      window.elBgm = audio;

      // Disable background music for deployment package (no music files available)
      const tracks = []; // Empty array - no background music files
      let i = 0;
      audio.volume = 0; audio.loop = false; audio.muted = true;

      function playCurrent(){
        if (tracks.length === 0) return; // Skip if no tracks available
        audio.src = tracks[i];
        const p = audio.play();
        if (p && p.catch) {
          const unlock = () => { audio.play().catch(()=>{}); window.removeEventListener('pointerdown', unlock); };
          window.addEventListener('pointerdown', unlock, { once:true });
        }
      }
      audio.addEventListener('ended', () => { i = (i+1) % tracks.length; playCurrent(); });
      audio.addEventListener('error', () => { i = (i+1) % tracks.length; playCurrent(); });
      // Disabled: document.addEventListener('DOMContentLoaded', playCurrent);
      audio.nextTrack = () => { i = (i+1) % tracks.length; playCurrent(); };
    })();

    /* ===================== Core ===================== */
  (function(){
    const IMG_DURATION_SEC = 10;
    const URL_DURATION_SEC = 20;
		const ANNOUNCE_GUARD_MS = 5000;   // guard ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏±‡∏á/‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
    const VERSION_POLL_MS = 21_600_000;

    // Global user interaction detection for autoplay enablement
    let hasUserInteracted = false;
    const enableAutoplay = () => { hasUserInteracted = true; };
    ['click', 'touchstart', 'keydown'].forEach(event => {
      document.addEventListener(event, enableAutoplay, { once: true });
    });

    const qs = new URLSearchParams(location.search);

    const playlistPath = `./data/playlist.json`;
    const mediasPath   = `./data/medias.json`;

    const elV   = document.getElementById('v');
    const elImg = document.getElementById('img');
    const ifrAnn= document.getElementById('ann');
    const elWeb = document.getElementById('web');
    const elStat= document.getElementById('status');
    const elVer = document.getElementById('ver');
    const ctaMain=document.getElementById('ctaMain');
    const ctaHead=document.getElementById('ctaHead');
    const unlockBtn=document.getElementById('unlock');

    const isHttpUrl = s => typeof s==='string' && /^https?:\/\//i.test(s);
    const extOf = p => { const m=(p||'').match(/\.([a-z0-9]+)(?:[?#]|$)/i); return m?m[1].toLowerCase():''; };
    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    const todayISO=()=>new Date().toISOString().slice(0,10);

    function isiOSSafari(){
      const ua=navigator.userAgent;
      const isiOS=/iPad|iPhone|iPod/.test(ua);
      const isSafari=/^((?!chrome|android).)*safari/i.test(ua);
      return isiOS || isSafari;
    }
    function withinDateRange(m){
      const t=todayISO(), s=m.start_date||null, e=m.end_date||null;
      if(s && t<s) return false; if(e && t>e) return false; return true;
    }
    function showStatus(msg){elStat.textContent=msg;elStat.classList.add('show')}
    function hideStatus(){elStat.classList.remove('show')}

    // Helper function for smooth fade transitions
    async function fadeOut(element) {
      element.classList.add('fade-out');
      element.classList.remove('fade-in');
      await sleep(750); // Wait for fade out to complete
      element.style.display = 'none';
      element.classList.remove('fade-out');
    }

    function fadeIn(element) {
      element.style.display = 'block';
      element.classList.remove('fade-out');
      element.classList.add('fade-in');
    }

    function hideAll(){
      elV.pause(); elV.removeAttribute('src'); elV.load(); elV.style.display='none';
      elImg.removeAttribute('src'); elImg.style.display='none';
      elWeb.src='about:blank'; elWeb.style.display='none';
      ifrAnn.src='about:blank'; ifrAnn.style.display='none';
      // Remove any transition classes
      elImg.classList.remove('fade-in', 'fade-out');
      elWeb.classList.remove('fade-in', 'fade-out');
      ifrAnn.classList.remove('fade-in', 'fade-out');
    }

    function buildMainMenuUrl(){
      return './menu.html';
    }

    function buildDetailUrl(meta){
      if(!meta) return null;
      const ref=(meta.id_ref||''); if(!ref) return null;
      const id=encodeURIComponent(meta.id_ref);


      // Determine type based on meta or item kind
      let type = 'unit'; // default for property listings
      if(meta.kind === 'restaurant' || ref.startsWith('rest') || ref.startsWith('dine')) type = 'restaurant';
      else if(meta.kind === 'shop' || ref.startsWith('shop') || ref.startsWith('od')) type = 'shop';

      const url = new URL('./product.html', location.href);
      url.searchParams.set('type', type);
      url.searchParams.set('id', ref);

      return url.toString();
    }

    // ‡∏ó‡∏≥ path ‡∏™‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô relative path ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö deployment package
    function resolveMediaSrc(s){
      if(!s) return s;
      if (/^https?:\/\//i.test(s)) return s;

      let resolved = s;

      // Convert /ann/medias/xxx.mp4 to ./medias/xxx.MP4
      if (s.startsWith('/ann/')) {
        resolved = './' + s.replace(/^\/ann\//, '');
      } else if (s.startsWith('/')) {
        resolved = '.' + s;
      }

      // Fix case sensitivity: .mp4 -> .MP4 for video files
      if (resolved.endsWith('.mp4')) {
        resolved = resolved.replace('.mp4', '.MP4');
      }

      return resolved;
    }

    async function loadJson(path){
      const res=await fetch(path,{cache:'no-store'});
      if(!res.ok) {
        const error = `HTTP ${res.status} ${res.statusText} @ ${path}`;
        console.error('loadJson failed:', error);
        throw new Error(error);
      }
      return res.json();
    }

    // ---------- ‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÄ‡∏•‡πà‡∏ô: ‡πÉ‡∏™‡πà‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå ----------
    async function buildSequence(){
      let playlistData, medias;
      try {
        console.log('Loading playlist from:', playlistPath);
        playlistData = await loadJson(playlistPath);
        console.log('Loaded playlist:', playlistData);
      } catch (e) {
        console.error('Failed to load playlist:', e);
        console.warn('Using fallback playlist data due to network/server error');
        showStatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏£‡∏≠‡∏á (Fallback mode)');
        setTimeout(hideStatus, 3000); // Hide after 3 seconds
        // Fallback playlist data for signage screens
        playlistData = {
          "loop": true,
          "items": [
            { "media_id": "unit001-01" },
            { "media_id": "shop001-01" }
          ]
        };
      }

      try {
        console.log('Loading medias from:', mediasPath);
        medias = await loadJson(mediasPath);
        console.log('Loaded medias:', medias);
      } catch (e) {
        console.error('Failed to load medias:', e);
        console.warn('Using fallback medias data due to network/server error');
        // Fallback medias data for signage screens
        medias = {
          "version": "1.0.0",
          "medias": [
            {
              "media_id": "unit001-01",
              "id_ref": "unit001",
              "media_type": "video",
              "file_name": "./medias/unit001-01.MP4",
              "approval_status": "approved",
              "start_date": "2025-01-01"
            },
            {
              "media_id": "shop001-01",
              "id_ref": "shop001",
              "media_type": "video",
              "file_name": "./medias/shop001-01.MP4",
              "approval_status": "approved",
              "start_date": "2025-01-01"
            }
          ]
        };
      }

      // Fix: playlist.json is a direct object, not wrapped in playlists
      let pl = {items:[],loop:true};
      if (playlistData) {
        pl = playlistData;
      }

      const ids=(pl.items||[]).map(x=>x.media_id);
      const list=Array.isArray(medias?.medias)?medias.medias:[];
      const byId=new Map(list.map(m=>[m.media_id,m]));
      const out=[];

      console.log('DEBUG buildSequence - Playlist data:', playlistData);
      console.log('DEBUG buildSequence - Media IDs to find:', ids);
      console.log('DEBUG buildSequence - Available medias:', list.map(m => m.media_id));

// Add all announcements for this project as first items
      let announcements = [];
      try {
        const announceRes = await fetch('./data/announce.json', {cache: 'no-store'});
        announcements = await announceRes.json();

        // Find all active announcements
        const projectAnnouncements = announcements.filter(a =>
          a.status === 'active'
        );

        // Add each announcement as a separate item
        projectAnnouncements.forEach((announcement, index) => {
          out.push({
            kind:'announcement',
            duration: Math.floor((announcement.display_duration || 8000) / 1000), // Convert ms to seconds
            meta: {
              id_ref: `announce:${announcement.announcement_id}`,
              announcement_data: announcement // Include the actual announcement data
            }
          });
        });
      } catch (error) {
        console.error('Failed to load announcements:', error);
        console.warn('Using fallback announcements data for signage');
        // Fallback announcements data for signage screens
        announcements = [
          {
            "announcement_id": "deep-cleaning-prj001",
            "title": "Deep Cleaning Services",
            "description": "Professional carpet cleaning services",
            "image_url": "images/announcements/deep-cleaning-prj001.jpg",
            "display_duration": 8000,
            "status": "active",
            "created_date": "2025-01-01"
          },
          {
            "announcement_id": "security-upgrade-prj001",
            "title": "Security System Update",
            "description": "New security patch installation",
            "image_url": "images/announcements/security-upgrade-prj001.jpg",
            "display_duration": 8000,
            "status": "active",
            "created_date": "2025-01-01"
          }
        ];

        // Process fallback announcements
        const projectAnnouncements = announcements.filter(a =>
          a.status === 'active'
        );

        projectAnnouncements.forEach((announcement, index) => {
          out.push({
            kind:'announcement',
            duration: Math.floor((announcement.display_duration || 8000) / 1000),
            meta: {
              id_ref: `announce:${announcement.announcement_id}`,
              announcement_data: announcement
            }
          });
        });
      }

      for(const id of ids){
        console.log(`DEBUG processing media ID: ${id}`);
        const m=byId.get(id);
        if(!m) {
          console.log(`DEBUG media not found for ID: ${id}`);
          continue;
        }

        console.log(`DEBUG found media:`, m);

        const approved=(m.approval_status||'').toLowerCase()==='approved';
        const inDate=withinDateRange(m);
        const inProject=true;

        console.log(`DEBUG filters - approved: ${approved}, inDate: ${inDate}, inProject: ${inProject}`);

        if(!approved||!inDate||!inProject) {
          console.log(`DEBUG media filtered out:`, m);
          continue;
        }

        let kind='video',src=m.file_name,duration=0;
        const ext=extOf(m.file_name);
        if(m.media_type==='image' || ['jpg','jpeg','png','gif','webp'].includes(ext)){
          kind='image'; duration=IMG_DURATION_SEC;
        }else if(m.media_type==='url' || isHttpUrl(m.file_name)){
          kind='url'; duration=URL_DURATION_SEC;
        }else{ kind='video'; }
        src = resolveMediaSrc(src);

        console.log(`DEBUG adding to sequence - kind: ${kind}, src: ${src}`);

        out.push({kind,src,duration,meta:m});
      }

      const loop=pl?.loop!==false;
      return {sequence:out,loop};
    }

    // CTA main ‚Üí menu.html
    function setupMainCta(){
      const url=buildMainMenuUrl();
      const go=()=>location.href=url;
      ctaMain.onclick=go;
      ctaMain.onkeydown=e=>{if(e.key==='Enter'||e.key===' ') go()};
    }

    // CTA head - tap to explore ‚Üí product page
    function showHeadFor(meta){
      if(!meta || !meta.id_ref) return;

      const url = buildDetailUrl(meta);
      if(!url) return;

      const go = () => location.href = url;
      ctaHead.onclick = go;
      ctaHead.onkeydown = e => { if(e.key==='Enter'||e.key===' ') go(); };
      ctaHead.style.pointerEvents = 'auto';
      ctaHead.style.cursor = 'pointer';
    }

    const lastKey='signage:lastIndex:prj003';
    let sequence=[],loopPlay=true,index=0;

    async function playAll(){
      hideStatus();
      if(sequence.length===0){showStatus('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏ô‡∏µ‡πâ');return;}
      const saved=parseInt(sessionStorage.getItem(lastKey)||'0',10);
      index=(!isNaN(saved)&&saved>=0&&saved<sequence.length)?saved:0;
      while(true){
        const item=sequence[index];
        sessionStorage.setItem(lastKey,String(index));
        try{await playItem(item);}catch(e){ console.error(e); }
        index++;
        if(index>=sequence.length){ if(!loopPlay) break; index=0; }
      }
    }

    async function playItem(item){
      hideAll();
      showHeadFor(item.meta);

      // Simple like morning version - no overlay manipulation!

      if (item.kind === 'video') {
        elV.src = item.src;

        elV.loop = false;
        elV.style.display = 'block';
        elV.muted = true;

        // ===== BGM helpers =====
        const elBgm = window.elBgm;
        // BGM functions disabled
        const bgmPause  = () => { /* disabled */ };
        const bgmResume = () => { /* disabled */ };
        const bgmNext   = () => { /* disabled */ };

        // bgmPause(); // disabled

        function hasAudioNow(v){
          try {
            if ('audioTracks' in v && v.audioTracks && v.audioTracks.length > 0) return true;
            if (typeof v.mozHasAudio === 'boolean') return v.mozHasAudio;
            if (typeof v.webkitAudioDecodedByteCount === 'number') return v.webkitAudioDecodedByteCount > 0;
          } catch(_) {}
          return false;
        }

        const metaReady = new Promise(res => {
          if (!isFinite(elV.duration) || elV.duration === 0) {
            elV.addEventListener('loadedmetadata', () => res(), { once: true });
          } else { res(); }
        });
        await Promise.race([metaReady, sleep(2000)]);

        // Enhanced autoplay handling with user interaction detection
        try {
          await elV.play();
        } catch (err) {
          console.warn('Autoplay failed:', err.message);
          // Show unlock button for user interaction
          if (unlockBtn) {
            unlockBtn.style.display = 'block';
            unlockBtn.onclick = () => {
              elV.play().catch(e => console.warn('Manual play failed:', e));
              unlockBtn.style.display = 'none';
            };
          }
        }

        let usingVideoAudio = false;
        if (hasAudioNow(elV)) { usingVideoAudio = true; elV.muted = true; }
        else {
          await sleep(600);
          if (hasAudioNow(elV)) { usingVideoAudio = true; elV.muted = true; }
          else { /* bgmResume(); */ }
        }

        await new Promise(resolve => {
          const sec = (isFinite(elV.duration) && elV.duration > 0) ? elV.duration : 30;
          const watchdog = setTimeout(() => { if (usingVideoAudio) /* bgmNext() */; resolve(); }, Math.ceil(sec + 1) * 1000);
          elV.onended = () => { clearTimeout(watchdog); if (usingVideoAudio) /* bgmNext() */; resolve(); };
          elV.onerror = () => { clearTimeout(watchdog); if (usingVideoAudio) /* bgmNext() */; resolve(); };
        });

        // No overlay manipulation needed
      }
      else if(item.kind==='image'){
        elImg.src=item.src;
        fadeIn(elImg);
        await sleep((item.duration||IMG_DURATION_SEC)*1000);
        await fadeOut(elImg);
      }
else if (item.kind === 'announcement') {
  // Direct announcement display - use pre-loaded announcement data

  try {
    let announcement = null;

    // Use pre-loaded announcement data if available
    if (item.meta.announcement_data) {
      announcement = item.meta.announcement_data;
    } else {
      // Fallback: load announcement data
      const announceRes = await fetch('./data/announce.json', {cache: 'no-store'});
      const announcements = await announceRes.json();
      announcement = announcements[0];
    }

    if (announcement) {
      // Transform announcement data EXACTLY like category.html does
      announcement.name_th = announcement.title_th || announcement.title_en || '‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®';
      announcement.name_en = announcement.title_en || announcement.title_th || 'Announcement';
      announcement.id = announcement.announcement_id;

      // Override "Tap to explore" to go to category page for announcements
      ctaHead.onclick = () => {
        const categoryUrl = './category.html?type=juristic';
        location.href = categoryUrl;
      };

      // DEBUG: Log what we have
      console.log('ANNOUNCEMENT DATA:', announcement);
      console.log('ANNOUNCEMENT IMAGE:', announcement.image);

      // Use the announcement image path and convert to relative path
      let announcementImagePath = './medias/placeholder.jpg'; // Default fallback

      if (announcement.image || announcement.image_url) {
        const imageSource = announcement.image || announcement.image_url;
        // Handle absolute URLs (https://) and relative paths
        if (imageSource.startsWith('http://') || imageSource.startsWith('https://')) {
          announcementImagePath = imageSource; // Use absolute URL as-is
        } else if (imageSource.startsWith('images/')) {
          announcementImagePath = './' + imageSource;
        } else if (imageSource.startsWith('/ann/')) {
          announcementImagePath = './' + imageSource.replace(/^\/ann\//, '');
        } else {
          announcementImagePath = imageSource;
        }
      }

      console.log('FINAL IMAGE PATH:', announcementImagePath);

      // Fallback to placeholder if specific announcement image doesn't exist
      elImg.onerror = () => {
        console.warn('Announcement image failed to load:', announcementImagePath);
        elImg.src = './medias/placeholder.jpg';
      };

      elImg.src = announcementImagePath;
      fadeIn(elImg);
      await sleep((item.duration || 15) * 1000);
      await fadeOut(elImg);
    } else {
      // No announcement found, just wait
      console.warn('No announcement found for:', item.meta);
      await sleep(2000);
    }
  } catch (error) {
    console.error('Error displaying announcement:', error);
    await sleep(2000);
  }
}
      else if(item.kind==='url'){
        // Morning version - no overlay manipulation
        const watchdog = setTimeout(()=>{ try{elWeb.src='about:blank';}catch{} }, Math.max((item.duration||URL_DURATION_SEC),5)*1000 + 3000);
        await new Promise(resolve=>{
          const done=()=>{ clearTimeout(watchdog); resolve(); };
          elWeb.onload = ()=>{ setTimeout(done, (item.duration||URL_DURATION_SEC)*1000); };
          elWeb.onerror= ()=>{ showStatus('‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'); setTimeout(done, 1500); };
          elWeb.src=item.src; elWeb.style.display='block';
        });
      }
    }

    function setupUnlock(){
      // Audio unlock disabled - no functionality needed
      return;
    }

    (function pollVersion(){
      let cur='';
      async function tick(){
        try{
          const r=await fetch('/version.txt',{cache:'no-store'});
          if(r.ok){
            const t=(await r.text()).trim();
            if(cur && t && t!==cur) location.reload();
            cur=t; elVer.textContent=t?`v ${t}`:'';
          }
        }catch(e){}
      }
      tick(); setInterval(tick, VERSION_POLL_MS);
    })();

    function init(){
      console.log('üöÄ Digital Signage Player (Yodeck Compatible)');
      console.log('‚öôÔ∏è Config loaded:', window.CONFIG ? 'Yes (Inline)' : 'No');
      console.log('üîß To change project: Edit PROJECT_ID in <head> section');

      setupMainCta();
      setupUnlock();
      buildSequence().then(({sequence:seq,loop})=>{
        console.log('Built sequence:', seq);
        sequence=seq; loopPlay=loop; playAll();
      }).catch(e=>{
        console.error('buildSequence error:', e);
        console.error('Error stack:', e.stack);
        showStatus('‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ' + e.message);
      });
    }

    init();
  })();
  </script>
</body>
</html>